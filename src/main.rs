extern crate autopilot;
// use std::mem;

/// 1. "fn main()" in src/main.rs(library crate) or src/lib.rs(binary crate) is a default entry point/crate root of the project.
/// 2. "fn" is a key word to declare a function.
/// 3. "println!" is a macro.
/// 4. macro is a kind of pseudo code for compiler to generate some code at compile time.
/// 5. ";" indicate the end of a statement. Every statements need a semicolon if it is not a final return statement in a block;

// mod sh;
// mod clo1;
// mod conditions;
// mod enum1;
// mod option1;
// mod ar1;
// mod err1;
// mod err2;
// mod err3;
// mod gen1;
// mod gen2;
// mod vec1;
// mod sl1;
// mod str1;
// mod str2;
// mod var1;
// mod lif1;
// mod lif2;
// mod map1;
// mod mo1;
// mod fn1;
// mod fn2;
// mod io1;
// mod io2;
// mod cr1;
// mod doc1;
// mod own1;
// mod own2;
// mod own3;
// mod own4;
// mod cmp1;
// mod const1;
// mod auto1;
// mod th1;
// mod th2;
// mod th3;
// mod th4;
mod th5;
// mod trait1;
// mod tt1;
// mod tt2;

//entry point, no parameters nor return values.
fn main() {
    // autopilot::key::type_string("Hello, world!", &[], 200., 0.);
    // let _ = autopilot::alert::alert("Hello, world!", None, None, None);
    // auto1::sine_mouse_wave();
    
    // let a = 1;
    // let b = Box::new(2);

    // println!("Hello, world!");
    // println!("a = {}, size of a = {}", a, mem::size_of_val(&a));
    // println!("b = {}, size of b = {}", b, mem::size_of_val(&b));

    // sh::heap();

    // clo1::clo1();

    // conditions::con1();

    // conditions::while1();

    // conditions::for1();

    // conditions::match1();

    // enum1::enums();

    // option1::op1();

    // ar1::ar1();

    // err1::err1();

    // err2::err2();

    // err3::err3();

    // gen1::gen1();

    // gen2::gen2();

    // vec1::vec1();

    // sl1::slice1();

    // str1::str1();

    // str2::str2();

    // var1::var1();

    // lif1::lif1();

    // lif1::lif2();

    // lif1::lif3();

    // lif1::lif4();

    // lif1::lif5();

    // lif2::case1();

    // map1::map1();

    // mo1::mo1();

    // fn1::fn1();

    // fn2::fn2();

    // io1::io1();

    // io2::io2();

    // cr1::cr1();

    // doc1::doc1();

    // own1::own1();

    // own2::own2();

    // own3::own3();

    // own4::own4();

    // cmp1::cmp1();

    // const1::const1();

    // th1::th1();

    // th2::th2();

    // th3::th3();

    // th4::th4();

    th5::th5();

    // trait1::trait1();

    // tt1::tt1();

    // tt2::tt2();
}
